import { NextResponse } from "next/server";
import { auth } from "@/auth";

export const POST = auth(async function POST(req) {
  if (!req.auth) return NextResponse.json({ message: "Not authenticated" }, { status: 401 });

  const formData = await req.formData();
  const modifiedImage = await modifyFile(formData);

  formData.set('image', modifiedImage);

  try {
    const req = await fetch(`https://api.imgbb.com/1/upload?key=${process.env.IMGBB_API_KEY}`, {
      method: "POST",
      body: formData,
    })

    const res = await req.json();
    return NextResponse.json({ message: "Image uploaded successfully", data: res.data.url, del: res.data.delete_url }, { status: 200 });
  } catch (error) {
    console.log(error);
    return NextResponse.json({ message: "Internal Server Error" }, { status: 500 });
  }
})

// ImgBB (The free image hosting provider) will not allow you to upload the same image twice.
// Instead, they'll return the URL of the original image if it already exists in their database.
// This includes the delete_url, so changing your user profile picture can sometimes also delete a group image.
// To prevent this, we can modify the file before uploading it to ImgBB.
// This is a function generated by ChatGPT, and so far it works quite well.

// Usage: const newFile = await modifyFile(file);
// Afterwards, add the file to the FormData object and upload it to ImgBB.
export async function modifyFile(formData: FormData): Promise<File> {
  // Step 1: Read the file into an ArrayBuffer
  const file = formData.get('image') as File;
  const arrayBuffer = await file.arrayBuffer();

  // Step 2: Create a Uint8Array from the ArrayBuffer
  const uint8Array = new Uint8Array(arrayBuffer);

  // Step 3: Add a unique identifier or timestamp to the file
  const timestamp = Date.now();
  const timestampBytes = new TextEncoder().encode(timestamp.toString());

  // Combine original file data with timestamp bytes
  const modifiedArrayBuffer = new Uint8Array(uint8Array.length + timestampBytes.length);
  modifiedArrayBuffer.set(uint8Array);
  modifiedArrayBuffer.set(timestampBytes, uint8Array.length);

  // Step 4: Create a new Blob from the modified ArrayBuffer
  const newBlob = new Blob([modifiedArrayBuffer], { type: file.type });

  // Step 5: Create a new File object from the Blob
  const newFile = new File([newBlob], file.name, { type: file.type });

  return newFile
}